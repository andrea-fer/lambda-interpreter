import { LRParser } from '@lezer/lr';
import { LRLanguage, indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';
import { completeFromList } from '@codemirror/autocomplete';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = LRParser.deserialize({
  version: 14,
  states: "!vQVQPOOOOQO'#C`'#C`ObQPO'#C_OgQPO'#CdOOQO'#Ci'#CiOOQO'#Ce'#CeQVQPOOOuQPO,58yOOQO,59O,59OOzQPO,59OOOQO-E6c-E6cOVQPO1G.eOOQO1G.j1G.jOOQO7+$P7+$P",
  stateData: "!Y~O[OS~OQSOVRO^PO~OQVO~OQSOUWOVRO^PO~OTZO~OQSOU[OVRO^PO~O",
  goto: "!Q^PPP_fPPP_mPPPwZSORUXZZQORUXZQUOQXRTYUXWTORUXR]Z",
  nodeNames: "âš  Program Variable Abstraction Lambda . ) ( Application",
  maxTerm: 14,
  nodeProps: [
    ["openedBy", 6,"("],
    ["closedBy", 7,")"]
  ],
  skippedNodes: [0],
  repeatNodeCount: 1,
  tokenData: "#P~R[XYwYZw]^wpqwxy!Yyz!_!O!P!d!Q![!i!c!}!i#R#S!i#T#o!i5s5t!z~|S[~XYwYZw]^wpqw~!_OV~~!dOU~~!iOT~~!nSQ~!Q![!i!c!}!i#R#S!i#T#o!i~#PO^~",
  tokenizers: [0],
  topRules: {"Program":[0,1]},
  tokenPrec: 0
});

const lambdaCalculusLanguage = LRLanguage.define({
    parser: parser.configure({
        props: [
            indentNodeProp.add({
                Application: delimitedIndent({ closing: ")", align: false }),
            }),
            foldNodeProp.add({
                Application: foldInside,
            }),
            styleTags({
                Variable: tags.variableName,
                "( )": tags.paren,
                Lambda: tags.keyword,
                ".": tags.keyword,
            }),
        ],
    })
});
const completions = lambdaCalculusLanguage.data.of({
    autocomplete: completeFromList([
        { label: "\\lambda", type: "keyword" },
    ]),
});
function LambdaLanguageSupport() {
    return new LanguageSupport(lambdaCalculusLanguage, [completions]);
}

export { LambdaLanguageSupport, lambdaCalculusLanguage };
